<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Interaction · Makie.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><a href="index.html"><img class="logo" src="assets/logo.png" alt="Makie.jl logo"/></a><h1>Makie.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="index.html">Home</a></li><li><span class="toctext">Basics</span><ul><li><a class="toctext" href="basic-tutorials.html">Tutorial</a></li><li><a class="toctext" href="statsmakie.html">StatsMakie Tutorial</a></li><li><a class="toctext" href="help_functions.html">Help functions</a></li><li><a class="toctext" href="functions-overview.html">Plotting functions overview</a></li><li><a class="toctext" href="signatures.html">Plot function signatures</a></li><li><a class="toctext" href="plot-attributes.html">Plot attributes</a></li><li><a class="toctext" href="colors.html">Colors</a></li><li><a class="toctext" href="theming.html">Config file</a></li><li><a class="toctext" href="axis.html">Axis</a></li><li><a class="toctext" href="animation.html">Animation</a></li><li class="current"><a class="toctext" href="interaction.html">Interaction</a><ul class="internal"><li><a class="toctext" href="#Node-interaction-pipeline-1"><code>Node</code> interaction pipeline</a></li><li><a class="toctext" href="#Atomic-interaction-functions-1">Atomic interaction functions</a></li><li><a class="toctext" href="#Interaction-using-the-mouse-1">Interaction using the mouse</a></li><li><a class="toctext" href="#Correct-way-to-animate-a-plot-1">Correct way to animate a plot</a></li></ul></li><li><a class="toctext" href="recipes.html">Plot Recipes</a></li><li><a class="toctext" href="output.html">Output</a></li><li><a class="toctext" href="troubleshooting.html">Troubleshooting</a></li></ul></li><li><span class="toctext">Developer Documentation</span><ul><li><a class="toctext" href="why-makie.html">Why <code>Makie</code>?</a></li><li><a class="toctext" href="abstractplotting_api.html">AbstractPlotting Reference</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>Basics</li><li><a href="interaction.html">Interaction</a></li></ul><a class="edit-page" href="https://github.com/JuliaPlots/MakieGallery.jl/blob/master/docs/src/interaction.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Interaction</span><a class="fa fa-bars" href="#"></a></div></header><div></div><div></div><div></div><h1><a class="nav-anchor" id="Interaction-1" href="#Interaction-1">Interaction</a></h1><p>Makie offers a sophisticated referencing system to share attributes across the Scene in your plot. This is great for interaction, animations and saving resources – also if the backend decides to put data on the GPU you might even share those in GPU memory.</p><p>Interaction and animations in Makie are handled by using <a href="https://juliagizmos.github.io/Observables.jl/stable/"><code>Observables</code></a>. An &quot;observable&quot;, called <code>Node</code> in Makie, is a structure that can have its value updated interactively. Interaction, animations and more are done using <code>Node</code>s and event triggers.</p><p>In this page we overview how the <code>Node</code>s pipeline works, how event-triggering works, and we give an introduction to the existing &quot;atomic&quot; functions for interaction. Examples that use interaction can be found in the Examples/<code>interaction</code> page (see <a href="https://simondanisch.github.io/ReferenceImages/gallery/index.html">Example Gallery</a> as well).</p><p>Have a peek at <a href="animation.html#Animation-1">Animation</a> for some more information once you&#39;re done with this.</p><h2><a class="nav-anchor" id="Node-interaction-pipeline-1" href="#Node-interaction-pipeline-1"><code>Node</code> interaction pipeline</a></h2><h3><a class="nav-anchor" id="The-Node-structure-1" href="#The-Node-structure-1">The <code>Node</code> structure</a></h3><p>A <code>Node</code> is a Julia structure that allows its value to be updated interactively. This means that anything that uses a <code>Node</code> could have its behavior updated interactively, as we will showcase in this page.</p><p>Let&#39;s start by creating a <code>Node</code>:</p><pre><code class="language-julia">x = Node(0.0) # set up a Node, and give it a default value of 0.0</code></pre><pre><code class="language-none">Observable{Float64} with 0 listeners. Value:
0.0</code></pre><p>The value of the <code>x</code> can be changed simply using <code>push!</code>:</p><pre><code class="language-julia">push!(x, 3.14);
x</code></pre><pre><code class="language-none">Observable{Float64} with 0 listeners. Value:
3.14</code></pre><p>Notice that you can access the value of a <code>Node</code> by indexing it with nothing, i.e. <code>x[]</code>. However, we recommend to use the function <a href="@ref"><code>to_value</code></a> to get the value of a <code>Node</code>, because <code>to_value</code> is a general function that works with all types instead of only <code>Node</code>s. E.g.:</p><pre><code class="language-julia">to_value(x)</code></pre><pre><code class="language-none">3.14</code></pre><h3><a class="nav-anchor" id="Nodes-depending-on-other-Nodes-1" href="#Nodes-depending-on-other-Nodes-1"><code>Node</code>s depending on other <code>Node</code>s</a></h3><p>You can create a node depending on another node using <a href="@ref"><code>lift</code></a>:</p><pre><code class="language-julia">f(a) = a^2
y = lift(a -&gt; f(a), x)</code></pre><pre><code class="language-none">Observable{Float64} with 0 listeners. Value:
9.8596</code></pre><p>Now, for every value of the <code>Node</code> <code>x</code>, the derived <code>Node</code> <code>y</code> will hold the value <code>f(x)</code>. Updating the value of <code>x</code> <em>will also update</em> the value of <code>y</code>!</p><p>For example:</p><pre><code class="language-julia">push!(x, 10.0)
for i in (x, y)
    println(to_value(i))
end</code></pre><pre><code class="language-none">10.0
100.0</code></pre><p>That is to say, the <code>Node</code> <code>y</code> maps the function <code>f</code> (which is <code>a -&gt; a^2</code> in this case) on <code>x</code> whenever the <code>Node</code> <code>x</code> is updated, and updates the corresponding value in <code>y</code>. This is the basis of updating <code>Node</code>s, and is used for updating plots in Makie. Any plot created based on this pipeline system will get updated whenever the nodes it is based on are updated!</p><p><em>Note: for now, <code>lift</code> is just an alias for <code>Observables.map</code>, and <code>Node</code> is just an alias for <code>Observables.Observable</code>. This allows decoupling of the APIs.</em></p><h3><a class="nav-anchor" id="Event-triggering-1" href="#Event-triggering-1">Event triggering</a></h3><p>Often it is the case that you want an event to be triggered each time a <code>Node</code> has its value updated. This is done using the <code>on-do</code> block from <code>Observables</code>. For example, the following code block &quot;triggers&quot; whenever <code>x</code>&#39;s value is changed:</p><pre><code class="language-julia">on(x) do val
    println(&quot;x just got the value $val&quot;)
end</code></pre><pre><code class="language-none">#3 (generic function with 1 method)</code></pre><p>As you can see, at we have run this block in Julia, but nothing happened yet. Instead, a function was defined. However, upon doing:</p><pre><code class="language-julia">push!(x, 5.0);</code></pre><pre><code class="language-none">5.0</code></pre><p>Boom! The event of the <code>on-do</code> block was triggered! We will be using this in the following paragraphs to establish interactivity.</p><p>For more info please have a look at <a href="https://juliagizmos.github.io/Observables.jl/stable/"><code>Observables</code></a>.</p><h2><a class="nav-anchor" id="Atomic-interaction-functions-1" href="#Atomic-interaction-functions-1">Atomic interaction functions</a></h2><p>This section overviews some simple and specific functions that make interaction much simpler.</p><p><em>coming soon...</em></p><p>There are three principal plot elements that you can use to make your plot interactive.  These are <code>Slider</code>, <code>textslider</code>, and <code>Button</code>.</p><h3><a class="nav-anchor" id="Slider-1" href="#Slider-1">Slider</a></h3><p>Sliders are quite simple to make.  They can be created by a call to the function <code>slider</code>, which usually takes the form:</p><pre><code class="language-julia">sl = slider(range::AbstractVector, raw = true, camera = campixel!, start = somevalue)</code></pre><p>which makes <code>sl</code> a Scene with only one <code>slider</code>.  The <code>slider</code> will go through <code>range</code>, and start at <code>somevalue</code>.  <code>range</code> must be a subtype of <code>AbstractVector</code>, meaning an <code>Array{T, 1}</code>, a <code>LinRange</code>, et cetera.</p><p>To access the value of the <code>slider</code> as an Observable, we can simply access <code>sl[end][:value]</code>, which will return an Observable which will contain the value that the slider is on.  You can then use that <code>Observable</code> in a call to <code>lift</code>.</p><p>A common way to use <code>slider</code>s is to <code>hbox</code> or <code>vbox</code> them with the Scene which depends on them.</p><h3><a class="nav-anchor" id="Button-1" href="#Button-1">Button</a></h3><p>Buttons are clickable markers that can call a function on click, passing to it the number of clicks so far, on each click.</p><h3><a class="nav-anchor" id="Textslider-1" href="#Textslider-1">Textslider</a></h3><p>Textsliders are a special case of sliders, with two key diferences - they automatically <code>hbox</code> a label with the slider, and they return a 2-tuple consisting of the <code>Scene</code> of the slider, and its value as an <code>Observable</code>.  Usually, they will be called like so:</p><pre><code class="language-julia">sl, ol = textslider(-1:0.01:1, &quot;label&quot;, start = 0)</code></pre><h2><a class="nav-anchor" id="Interaction-using-the-mouse-1" href="#Interaction-using-the-mouse-1">Interaction using the mouse</a></h2><p>A few default Nodes are already implemented in a <code>scene</code>&#39;s Events (see them in <code>scene.events</code>), so to use them in your interaction pipeline, you can simply <code>lift</code> them.</p><p>For example, for interaction with the mouse cursor, <code>lift</code> the <code>mouseposition</code> signal.</p><pre><code class="language-julia">pos = lift(scene.events.mouseposition) do mpos
    # do stuff
end</code></pre><h2><a class="nav-anchor" id="Correct-way-to-animate-a-plot-1" href="#Correct-way-to-animate-a-plot-1">Correct way to animate a plot</a></h2><p>You can animate a plot in a <code>for</code> loop:</p><pre><code class="language-julia">r = 1:10
for i = 1:length(r)
    push!(s[:markersize], r[i])
    AbstractPlotting.force_update!()
    sleep(1/24)
end</code></pre><p>But, if you <code>push!</code> to a plot, it doesn&#39;t necessarily get updated whenever an attribute changes, so you must call <code>force_update!()</code>.</p><p>A better way to do it is to access the attribute of a plot directly using its symbol, and when you change it, the plot automatically gets updated live, so you no longer need to call <code>force_update!()</code>:</p><pre><code class="language-julia">for i = 1:length(r)
    s[:markersize] = r[i]
    # AbstractPlotting.force_update!() is no longer needed
    sleep(1/24)
end</code></pre><p>Similarly, for plots based on functions:</p><pre><code class="language-julia">scene = Scene()
v = range(0, stop=4pi, length=50)
f(v, t) = sin(v + t) # some function
s = lines!(
    scene,
    lift(t -&gt; f.(v, t), time),
)[end];

for i = 1:length(v)
    push!(time, i)
    sleep(1/24)
end</code></pre><footer><hr/><a class="previous" href="animation.html"><span class="direction">Previous</span><span class="title">Animation</span></a><a class="next" href="recipes.html"><span class="direction">Next</span><span class="title">Plot Recipes</span></a></footer></article></body></html>
